"""
cvescan/nvd.py
    -- download and parse NVD XML feeds
"""
import requests
import tempfile
import os
import re
import xml.etree.ElementTree as et

FEED_URL = 'http://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-%s.xml'

NAMESPACES = {
    'def': 'http://scap.nist.gov/schema/feed/vulnerability/2.0',
    'vuln': 'http://scap.nist.gov/schema/vulnerability/0.4',
    'cvss': 'http://scap.nist.gov/schema/cvss-v2/0.2'
}

docs = {}

cpe_re = re.compile('^cpe:\/(.+)')


def get(year, path=None, update=False, verbose=False):
    """
    Download the NVD XML feed for the specified year (defaults to current year).
    Returns an XML parser object and the local path to the file.
    """

    # if a path was not specified, create a temporary directory for our use.
    tempdir = None
    if not path:
        tempdir = tempfile.mkdtemp()
        path = os.path.join(tempdir, 'nvdcve-2.0-%s.xml' % year)

    # do not update an existing local copy unless update is True
    if not os.path.exists(path) or update:
        if verbose:
            print "Downloading feed for year %s" % year
            if tempdir:
                print "XML feed will be stored as %s" % path

        # write the XML file to disk in chunks
        with open(path, 'wb') as f:
            r = requests.get(FEED_URL % year, stream=True)
            f.writelines(r.iter_content(1024))
    elif verbose:
        print "Using existing XML file %s" % path

    docs[year] = (et.parse(path), path)
    return docs[year]


def scan(year, name, version, verbose=False):
    """
    Scan an NVD XML feed for vulnerabilities matching the specified package name and version.
    """
    (p, path) = docs[year] if year in docs else get(year=year)
    vulnerabilities = []
    if verbose:
        print "Scanning for %s==%s in %s" % (name, version, year)
    root = p.getroot()
    for entry in root.findall('./{%s}entry' % NAMESPACES['def']):
        swlist = entry.find('./{%s}vulnerable-software-list' % NAMESPACES['vuln'])
        if swlist is not None:
            for sw in swlist.findall('./{%s}product' % NAMESPACES['vuln']):
                m = cpe_re.match(sw.text)
                if m is not None:
                    #[part, vendor, prod, ver, update, edition, lang]
                    parts = m.group(1).split(':')
                    try:
                        parts[2].lower().index(name.lower())
                    except ValueError:
                        continue
                    if parts[3] == version:
                        vulnerabilities.push(entry.attrib['id'])
                        if verbose:
                            print "%s==%s: %s" % (name, version, entry.attrib['id'])
    return vulnerabilities
